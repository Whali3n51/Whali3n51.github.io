<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  
    <meta name="description" content="个人记录和分享学习经历的一个小博客">
  

  

  
    <meta name="author" content="Whali3n51">
  

  

  

  <title>Angr笔记 | Whali3n51&#39;s blog</title>

  

  
    <link rel="icon" href="/logo.jpg">
  

  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
    <link href="https://cdn.bootcss.com/highlight.js/9.15.6/styles/github.min.css" rel="stylesheet">
  

  <link rel="stylesheet" href="/css/style.css">
<link rel="alternate" href="/atom.xml" title="Whali3n51's blog" type="application/atom+xml">
</head>
<body>
  <div id="container">
    <!-- header -->
<header class="header">
  <div class="header-navbar">
    <div class="header-navbar-left">
      <h1 class="header-navbar-logo">
        <a href="/">
          
            <img src="/css/images/logo.png" alt="Whali3n51&#39;s blog" />
          
        </a>
      </h1>
    </div>
    <div class="header-navbar-right">
      <div class="header-navbar-btn">
        <div></div>
        <div></div>
        <div></div>
      </div>
      <ul class="header-navbar-list">
        
          <li class="header-navbar-item"><a href="/">主页</a></li>
        
          <li class="header-navbar-item"><a href="/about">关于</a></li>
        
          <li class="header-navbar-item"><a href="/links">友链</a></li>
        
          <li class="header-navbar-item"><a href="/tags">标签</a></li>
        
          <li class="header-navbar-item"><a href="/categories">分类</a></li>
        
      </ul>
    </div>
  </div>
</header>

    <section id="main"><!-- 文章详情页 -->


<!-- banner container -->
<div class="banner-container">

  
  

  
  

  
  

  
  

  
  
    
      <div class="banner-content full-content">
        <div class="post-image" style="background-image: url(/css/images/mountain.jpg)"></div>
        <div class="post-text">
          <div class="type-wrap">
            
          </div>
          <h1 class="title-wrap">Angr笔记</h1>
          <h2 class="title-sub-wrap">
            <strong>Whali3n51</strong>
            <span>发布于</span>
            
  <a href="javascript:;" target="_blank" rel="noopener" class="article-date">
    <time datetime="2022-05-18T11:34:05.000Z" itemprop="datePublished">2022-05-18</time>
  </a>

          </h2>
        </div>
      </div>
    
  

  
  

</div>

<!-- 文章内容 -->

<div class="body-container">
  <article id="article-container" class="main-container article-container">
    <div class="article-content">
      
      

      <div class="article-entry">
        <p>本文是学习<a href="https://github.com/jakespringer/angr_ctf" target="_blank" rel="noopener">angr_ctf</a>所写。这里是我的一点总结和想法。</p>
<h2><span id="安装angr">安装angr</span></h2><p>我安装的环境是ubuntu20.04+python3。首先安装python,确保python默认为python3而不是python2。这个问题在ubuntu20.04上面有体现。如果出现默认python是python2，建议先卸载python2，等python3的虚拟环境安装完成之后再重新安装python2。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get autoremove --purge python2* <span class="comment">#卸载python2</span></span><br><span class="line"><span class="comment">#进入/usr/bin目录给python3创建个软链接，这样默认python就是python3了</span></span><br><span class="line"><span class="built_in">cd</span> /usr/bin</span><br><span class="line">ln -s /usr/bin/python3.8 python</span><br></pre></td></tr></table></figure>

<p>接下来就是安装虚拟环境。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install python-dev libffi-dev build-essential <span class="comment">#安装依赖</span></span><br><span class="line">pip3 install virtualenvwrapper</span><br></pre></td></tr></table></figure>

<p>设置环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/Python-workhome</span><br><span class="line"><span class="built_in">source</span> /usr/<span class="built_in">local</span>/bin/virtualenvwrapper.sh</span><br></pre></td></tr></table></figure>

<p>这里<code>source /usr/local/bin/virtualenvwrapper.sh</code>执行如果报错为没有找到文件，建议找一下自己的virtualenvwrapper安装目录。如果报错为没有模块的话，建议检查一下自己默认python是否为python3。如果这两步执行没有错误的话，建议写入~/.bashrc中，这样就不用每次启动bash都要输入一次。</p>
<p>接下来就是进入虚拟环境安装angr</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkvirtualenv virangr</span><br><span class="line">workon <span class="comment">#查看目前所在虚拟环境</span></span><br><span class="line">pip3 install angr</span><br></pre></td></tr></table></figure>

<p>如此angr就安装上了，可以正常使用了。后续python2安装上也不影响使用。只要保证默认python是python3即可。</p>
<h2><span id="angr笔记">angr笔记</span></h2><p>本文所有程序全部是需要输入密码，然后判断密码是否正确，不同题目难度各异，依次递增。输入正确回显为”Good Job.”,反之则为”Try again.”</p>
<h3><span id="00_angr_find">00_angr_find</span></h3><p>这个例子就是angr的开端，脚本并不复杂，简单介绍一下angr的思路。angr为符号执行，在不运行程序的情况下，通过分析程序，计算出一系列的输入，这个输入可以使程序跑到你想要达到的特定位置。例如，在本题中，输入一串正确的字符串来使程序输出”Good Job.”。因此在程序里面输出”Good Job.”的地方就是我们想要达到的地方。angr通过你指定的参数脚本内容在不运行程序的情况下来计算出正确的输入字符串。</p>
<p>本题较为简单，主要目的是介绍一下angr脚本的初始框架，以后大致是在此基础上进行修修改改。</p>
<p>看题</p>
<p><img src="1.png" alt></p>
<p>要想得到这个正确的password，通常我们的思路就是对complex_function进行一个常规的逆向。但是学习了angr之后并不需要这么做，complex_function可以使用angr自动分析。如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  <span class="comment">#简单创建一个angr的一个工程，指明需要分析的程序</span></span><br><span class="line">  path_to_binary = <span class="string">r'00_angr_find'</span>  <span class="comment"># :string</span></span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line">  <span class="comment">#指定分析程序的起始地址，entry_state()为程序默认起始地址</span></span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line">  <span class="comment">#根据指定的入口地址创建一个模拟器</span></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line">  <span class="comment">#指定想要达到的地址，这里为0x804867D就是程序执行到puts("Good Job.")的地址。</span></span><br><span class="line">  print_good_address = <span class="number">0x804867D</span>   <span class="comment"># :integer (probably in hexadecimal)</span></span><br><span class="line">  <span class="comment">#根据通过初始化的模拟器计算出想要到达地址的输入。</span></span><br><span class="line">  simulation.explore(find=print_good_address)</span><br><span class="line">  <span class="comment">#找到正确的输入就打印</span></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    <span class="comment">#正确的模拟路径不止一个，这里只选择第一个。</span></span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#打印出该次模拟器模拟路径的输入，即正确输入</span></span><br><span class="line">    print(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="comment">#没找到就抛异常</span></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>

<p>框架很简单，angr分析程序大致流程也就这样。</p>
<h3><span id="01_angr_avoid">01_angr_avoid</span></h3><p>介绍了不想进入的分支的angr设置。如题</p>
<p><img src="2.png" alt></p>
<p><img src="3.png" alt></p>
<p><img src="4.png" alt></p>
<p>本题main函数分支十分庞大，同时要想正确的输出”Good Job.”不能进去一次avoid_me函数。因此需要在angr中设置不想进入的地方。如果设置该字段，如果模拟器分析到该地方则会跳过该次分析，进行下一次分析。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  path_to_binary = <span class="string">r"01_angr_avoid"</span></span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line">  print_good_address = <span class="number">0x80485E5</span></span><br><span class="line">  will_not_succeed_address = <span class="number">0x80485A8</span></span><br><span class="line">  <span class="comment">#增加了avoid,设置该参数则分析的时候到该地方则会结束该次分析，进行下一次分析。</span></span><br><span class="line">  simulation.explore(find=print_good_address, avoid=will_not_succeed_address)</span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    print(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>



<h3><span id="02_angr_find_condition">02_angr_find_condition</span></h3><p>本题介绍了不知道正确地址的程序该如何使用。如果本题不知道打印”Good Job.”的地址，那么该怎么办？</p>
<p>本题介绍了simulation.explore(find=True,avoid=False). find和avoid参数不仅仅可以是函数地址，还可以是Boolean。当find=True时，证明本次分析成功。avoid=True时，则跳过该次分析，进入下一次分析。</p>
<p><img src="5.png" alt></p>
<p>此时我们只需要判断什么时候给find为True,什么时候给avoid为True.如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span><span class="params">(state)</span>:</span></span><br><span class="line">    <span class="comment">#可以通过获取程序的打印结果来判断是否执行成功</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="comment">#打印结果含有'Good Job.',则给find返回True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">b'Good Job.'</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span><span class="params">(state)</span>:</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="comment">#打印结果含有'Good Job.',则给avoid返回True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line">  </span><br><span class="line">  simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    print(solution_state.posix.dumps(sys.stdin.fileno()))</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>

<h3><span id="小总结01">小总结01</span></h3><p>如上三个题都是针对 simulation.explore()函数。想要找到的地址就设置给find或者想要得到的输出得到之后就给find设置为True.想要避免的函数地址就设置给avoid或者不想得到的输出得到之后给avoid设置为True.</p>
<h3><span id="03_angr_symbolic_registers">03_angr_symbolic_registers</span></h3><p>前三题都是只用一次输入一个字符串，本题引入一次输入多个输入变量。angr简单的处理不了一次输入多个变量输入，只能简单处理单个变量。因此这里介绍angr处理多个变量.</p>
<p><img src="6.png" alt></p>
<p>​    <img src="7.png" alt></p>
<p><img src="9.png" alt></p>
<p><img src="10.png" alt></p>
<p>如题本题在get_user_input函数中需要输入三个数据，输入的数据存放在eax,ebx,edx中。三个参数进入三个不同的complex_function。angr的处理方式如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line">  <span class="comment">#这里不能从程序起始地址开始，需要跳过函数输入的地方开始，然后采用符号插入的方式告诉angr输入变量。</span></span><br><span class="line">  start_address = <span class="number">0x8048980</span>   <span class="comment"># :integer (probably hexadecimal)</span></span><br><span class="line">  <span class="comment">#注意这里是blank_state</span></span><br><span class="line">  initial_state = project.factory.blank_state(addr=start_address)</span><br><span class="line">  <span class="comment">#指定输入变量的变量占用bit数，多个变量就类似设置。这里有三个变量就设置三个</span></span><br><span class="line">  password0_size_in_bits = <span class="number">32</span>  <span class="comment"># :integer</span></span><br><span class="line">  <span class="comment">#创建位向量，angr通过改变该变量来模拟出正确的结果，</span></span><br><span class="line">  <span class="comment">#第一个参数仅仅是一个angr引用的名字而已，随便取，建议别重复。</span></span><br><span class="line">  password0 = claripy.BVS(<span class="string">'password0'</span>, password0_size_in_bits)</span><br><span class="line">  password1_size_in_bits = <span class="number">32</span>  <span class="comment"># :integer</span></span><br><span class="line">  password1 = claripy.BVS(<span class="string">'password1'</span>, password1_size_in_bits)</span><br><span class="line">  password2_size_in_bits = <span class="number">32</span>  <span class="comment"># :integer</span></span><br><span class="line">  password2 = claripy.BVS(<span class="string">'password2'</span>, password2_size_in_bits)</span><br><span class="line"></span><br><span class="line">  <span class="comment">#这里进行符号插入，三个输入变量都是存放在寄存器，则使之一一对应。</span></span><br><span class="line">  initial_state.regs.eax = password0</span><br><span class="line">  initial_state.regs.ebx = password1</span><br><span class="line">  initial_state.regs.edx = password2</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line">  <span class="comment">#和题02一样</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span><span class="params">(state)</span>:</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b'Good Job.'</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span><span class="params">(state)</span>:</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#处理之后得到的值有多个，使用eval函数，只保留一个</span></span><br><span class="line">    solution0 = solution_state.se.eval(password0)</span><br><span class="line">    solution1 = solution_state.se.eval(password1)</span><br><span class="line">    solution2 = solution_state.se.eval(password2)</span><br><span class="line">    <span class="comment">#将值按照输入的格式打印出来</span></span><br><span class="line">    solution = <span class="string">r"%x %x %x"</span>%(solution0,solution1,solution2)  <span class="comment"># :string</span></span><br><span class="line">    print(solution)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>

<h3><span id="04_angr_symbolic_stack">04_angr_symbolic_stack</span></h3><p>本题和上题类似，但是这次输入的变量是存放在栈上。</p>
<p><img src="8.png" alt></p>
<p><img src="11.png" alt></p>
<p>可以从汇编上看到，通过scanf输入的两个变量一个存放在距离栈底0xc的地方，一个存放在距离占地0x10的地方。angr处理如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line">  <span class="comment">#这里开始位置很重要，开始位置决定了栈空间</span></span><br><span class="line">  <span class="comment">#我们这里还是需要在scanf后面调用，但是是在0x8048694还是0x8048697.</span></span><br><span class="line">  <span class="comment">#若是在0x8048694，这个汇编调用其实是在平衡scanf的参数调用栈的</span></span><br><span class="line">  <span class="comment">#angr分析时构造的栈就会比原程序的栈向下偏移0x10</span></span><br><span class="line">  <span class="comment">#因此我们需要从0x8048697开始，使之布局与原程序一致。</span></span><br><span class="line">  start_address = <span class="number">0x8048697</span></span><br><span class="line">  initial_state = project.factory.blank_state(addr=start_address)</span><br><span class="line">  <span class="comment">#初始化栈</span></span><br><span class="line">  initial_state.regs.ebp = initial_state.regs.esp</span><br><span class="line">  <span class="comment">#如题03</span></span><br><span class="line">  password0 = claripy.BVS(<span class="string">'password0'</span>, <span class="number">32</span>)</span><br><span class="line">  password1 = claripy.BVS(<span class="string">'password1'</span>, <span class="number">32</span>)</span><br><span class="line">  <span class="comment">#这里计算出填充字符，使构造栈布局与程序栈布局类似</span></span><br><span class="line">  <span class="comment">#关键是让输入变量存放的栈与构造出来的栈布局对应上</span></span><br><span class="line">  padding_length_in_bytes = <span class="number">0x8</span>  <span class="comment"># :integer</span></span><br><span class="line">  initial_state.regs.esp -= padding_length_in_bytes</span><br><span class="line">  <span class="comment">#当构造栈向上抬了0x8个字节后，再push一个4个字节大小的angr变量就与存放在0xc的输入变量对应上了</span></span><br><span class="line">  initial_state.stack_push(password0)  <span class="comment"># :bitvector (claripy.BVS, claripy.BVV, claripy.BV)</span></span><br><span class="line">  <span class="comment">#同理在push一个4个字节大小的angr变量就与存放在0x10的输入变量对应上了</span></span><br><span class="line">  initial_state.stack_push(password1)</span><br><span class="line"></span><br><span class="line">  <span class="comment">#如下就与题03类似了</span></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span><span class="params">(state)</span>:</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b'Good Job.'</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span><span class="params">(state)</span>:</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    solution0 = solution_state.se.eval(password0)</span><br><span class="line">    solution1 = solution_state.se.eval(password1)</span><br><span class="line"></span><br><span class="line">    solution = <span class="string">r"%u %u"</span>%(solution0,solution1)</span><br><span class="line">    print(solution)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>

<p>本题关键就是要定位好原程序存放输入的变量与我们构造的位向量在栈上的位置保持一致，以便模拟器正确的计算出来正确的输入值。</p>
<h3><span id="05_angr_symbolic_memory">05_angr_symbolic_memory</span></h3><p>本题的存放输入的变量存放在bss段上</p>
<p><img src="12.png" alt></p>
<p>本题较为简单，只需要找到变量输入地址即可。存放在bss段，则地址固定，angr处理如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  start_address = <span class="number">0x8048601</span> </span><br><span class="line">  initial_state = project.factory.blank_state(addr=start_address)</span><br><span class="line">  <span class="comment">#每个变量需要输入八个字节，因此8*8=64</span></span><br><span class="line">  <span class="comment">#创建位向量</span></span><br><span class="line">  password0 = claripy.BVS(<span class="string">'password0'</span>, <span class="number">64</span>)</span><br><span class="line">  password1 = claripy.BVS(<span class="string">'password1'</span>, <span class="number">64</span>)</span><br><span class="line">  password2 = claripy.BVS(<span class="string">'password2'</span>, <span class="number">64</span>)</span><br><span class="line">  password3 = claripy.BVS(<span class="string">'password3'</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">#通过memory.store()可以将angr变量与地址绑定</span></span><br><span class="line">  password0_address = <span class="number">0xA1BA1C0</span></span><br><span class="line">  initial_state.memory.store(password0_address, password0)</span><br><span class="line">  password1_address = <span class="number">0xA1BA1C8</span></span><br><span class="line">  initial_state.memory.store(password1_address, password1)</span><br><span class="line">  password2_address = <span class="number">0xA1BA1D0</span></span><br><span class="line">  initial_state.memory.store(password2_address, password2)</span><br><span class="line">  password3_address = <span class="number">0xA1BA1D8</span></span><br><span class="line">  initial_state.memory.store(password3_address, password3)</span><br><span class="line"></span><br><span class="line">  <span class="comment">#如下处理一致</span></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span><span class="params">(state)</span>:</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span><span class="params">(state)</span>:</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#这里需要把正确结果处理为字符串输出</span></span><br><span class="line">    solution0 = solution_state.solver.eval(password0,cast_to=bytes).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    solution1 = solution_state.solver.eval(password1,cast_to=bytes).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    solution2 = solution_state.solver.eval(password2,cast_to=bytes).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    solution3 = solution_state.solver.eval(password3,cast_to=bytes).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    solution = <span class="string">r"%8s %8s %8s %8s"</span>%(solution0,solution1,solution2,solution3)</span><br><span class="line">    print(solution)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>

<h3><span id="06_angr_symbolic_dynamic_memory">06_angr_symbolic_dynamic_memory</span></h3><p><img src="13.png" alt></p>
<p>两个输入变量在堆上，地址随机。angr需要使用任意一个无用已知的内存块并且用这内存块地址覆盖指向原来数据内存的指针，这样就无需知道malloc分配的随机地址了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  start_address = <span class="number">0x8048699</span></span><br><span class="line">  initial_state = project.factory.blank_state(addr=start_address)</span><br><span class="line">  password0 = claripy.BVS(<span class="string">'password0'</span>, <span class="number">64</span>)</span><br><span class="line">  password1 = claripy.BVS(<span class="string">'password1'</span>, <span class="number">64</span>)</span><br><span class="line">  <span class="comment">#首先找到buffer0的地址0xABCC8A4</span></span><br><span class="line">  <span class="comment">#然后用任意的一个内存块地址（这里用的0xABCC760）覆盖buffer0的值</span></span><br><span class="line">  fake_heap_address0 = <span class="number">0xABCC760</span></span><br><span class="line">  pointer_to_malloc_memory_address0 = <span class="number">0xABCC8A4</span></span><br><span class="line">  <span class="comment">#这里是在进行覆盖，但是memory.store默认是大端序，需要指定endness设置为自己架构的端序。</span></span><br><span class="line">  <span class="comment">#project.arch.memory_endness代表就是当前运行的架构端序</span></span><br><span class="line">  initial_state.memory.store(pointer_to_malloc_memory_address0, fake_heap_address0, endness=project.arch.memory_endness)</span><br><span class="line">  fake_heap_address1 = <span class="number">0xABCC780</span></span><br><span class="line">  pointer_to_malloc_memory_address1 = <span class="number">0x0ABCC8AC</span></span><br><span class="line">  initial_state.memory.store(pointer_to_malloc_memory_address1, fake_heap_address1, endness=project.arch.memory_endness)</span><br><span class="line">  <span class="comment">#将指向数据指针修改为已知的地址之后，可以如题05一样把存放输入变量与我们创建的位向量绑定在一起。</span></span><br><span class="line">  initial_state.memory.store(fake_heap_address0, password0)</span><br><span class="line">  initial_state.memory.store(fake_heap_address1, password1)</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span><span class="params">(state)</span>:</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span><span class="params">(state)</span>:</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    solution0 = solution_state.se.eval(password0,cast_to=bytes).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    solution1 = solution_state.se.eval(password1,cast_to=bytes).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    solution = <span class="string">r"%8s %8s"</span>%(solution0,solution1)</span><br><span class="line">    print(solution)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>

<h3><span id="07_angr_symbolic_file">07_angr_symbolic_file</span></h3><p>本题是通过从文件获取信息来读取password。原作者为了维持所有程序的一致性，因此在终端写入需要输入password。这个password在ignore_me的函数中将password写入了文件。正如作者所说，不用理会这个函数。我们就只需要当作程序是从文件中获取输入即可。</p>
<p><img src="14.png" alt></p>
<p>本题处理手法众多，可以用上述的05题的办法来弄出password。为了学习如何处理文件，这里只用符号化的手法来处理文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line">  <span class="comment">#此时的开始地址为从读入文件开始</span></span><br><span class="line">  start_address = <span class="number">0x080488ED</span></span><br><span class="line">  initial_state = project.factory.blank_state(addr=start_address)</span><br><span class="line">  <span class="comment">#读取的文件名</span></span><br><span class="line">  filename = <span class="string">r'OJKSQYDP.txt'</span>  <span class="comment"># :string</span></span><br><span class="line">  <span class="comment">#看似读入64个字节，但是只处理和判断了前8个字节</span></span><br><span class="line">  symbolic_file_size_bytes = <span class="number">8</span></span><br><span class="line">  <span class="comment">#创建一个位向量</span></span><br><span class="line">  password = claripy.BVS(<span class="string">'password'</span>, symbolic_file_size_bytes * <span class="number">8</span>)</span><br><span class="line">  <span class="comment"># 创建一个符号文件，content指定的是文件内容</span></span><br><span class="line">  password_file = angr.storage.SimFile(filename, content=password)</span><br><span class="line">  <span class="comment"># 将我们创建的符号文件加入到符号文件系统中，因此模拟器读取的文件就是我们创建符号文件。</span></span><br><span class="line">  initial_state.fs.insert(filename,password_file)</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span><span class="params">(state)</span>:</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span><span class="params">(state)</span>:</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    solution = solution_state.se.eval(password,cast_to=bytes).decode(<span class="string">"UTF-8"</span>)</span><br><span class="line"></span><br><span class="line">    print(solution)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>

<h3><span id="小总结-02">小总结 02</span></h3><p>上述几个题的思路都是使我们创建的位向量与存放输入的变量的位置对应起来或者是用位向量的值代替输入值（如07题）。其实很容易联想到，位向量的改变就相当于原程序启动之后输入值的改变。angr就是在模拟程序运行，不断地改变位向量的值模拟运行到达预期结果，最后得到正确的输入值。</p>
<h3><span id="08_angr_constraints">08_angr_constraints</span></h3><p>本题介绍如何添加约束。</p>
<p><img src="15.png" alt></p>
<p><img src="16.png" alt></p>
<p><img src="17.png" alt></p>
<p>依据前面的经验，我们需要从scanf之后指定开始地址。但是本题的判断条件不像前面以字符常量的形式与我们输入的值进行比较。如果按照前面那么做，首先模拟器在模拟时，password上并没有值，给password赋值的代码在scanf前面。其次在check函数中，字符串比较时一个一个字符比较，这会产生路径爆炸。每一次循环会产生两个结果（正确或错误），这么来说会有2^16次比较结果，这样做很浪费时间。因此可以手动添加约束条件来代替这个判断函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  start_address = <span class="number">0x8048625</span></span><br><span class="line">  initial_state = project.factory.blank_state(addr=start_address)</span><br><span class="line"></span><br><span class="line">  password = claripy.BVS(<span class="string">'password'</span>, <span class="number">16</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">  password_address = <span class="number">0x804A050</span></span><br><span class="line">  initial_state.memory.store(password_address, password)</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line">  <span class="comment">#到达判断函数前停止</span></span><br><span class="line">  address_to_check_constraint = <span class="number">0x8048673</span> </span><br><span class="line">  simulation.explore(find=address_to_check_constraint)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#将计算过的password的位向量获取出来赋值给约束位向量</span></span><br><span class="line">    constrained_parameter_address =  <span class="number">0x804A050</span></span><br><span class="line">    constrained_parameter_size_bytes = <span class="number">16</span></span><br><span class="line">    constrained_parameter_bitvector = solution_state.memory.load(</span><br><span class="line">      constrained_parameter_address,</span><br><span class="line">      constrained_parameter_size_bytes</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#判断成功的结果</span></span><br><span class="line">    constrained_parameter_desired_value = <span class="string">r"AUPDNNPROEZRJWKB"</span> <span class="comment"># :string</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#约束位向量与成功的结果比较，相等则继续，不相等则本次模拟结果不成功，跳过进行下一次模拟。</span></span><br><span class="line">    solution_state.add_constraints(constrained_parameter_bitvector == constrained_parameter_desired_value)</span><br><span class="line"></span><br><span class="line">    solution = solution_state.solver.eval(password,cast_to=bytes).decode(<span class="string">"UTF-8"</span>)</span><br><span class="line">    print(solution)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>

<h3><span id="09_angr_hooks">09_angr_hooks</span></h3><p>本题介绍了Angr的hooks方式，将跳过的函数替换为自己的函数</p>
<p><img src="18.png" alt></p>
<p><img src="19.png" alt></p>
<p>如题，获取一段输入之后加密进入check_equals函数并将比较结果保存。然后再获取一段输入之后和加密之后的password直接比较。</p>
<p>依据上一题的经验，进入check_equals函数会造成路径爆炸。因此我们需要跳过它，上述红框的地方就是我们需要跳过的地方。后面的代码功能我们完全可以依靠angr完成。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line">  <span class="comment">#这里我们可以从函数开头进入，因为没有多个变量接受输入值。</span></span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">  <span class="comment">#我们需要跳过的函数地址的起始</span></span><br><span class="line">  check_equals_called_address = <span class="number">0x80486A9</span> </span><br><span class="line">  <span class="comment">#需要跳过的字节长度=0x80486BB-0x80486A9</span></span><br><span class="line">  instruction_to_skip_length = <span class="number">18</span></span><br><span class="line"><span class="meta">  @project.hook(check_equals_called_address, length=instruction_to_skip_length)</span></span><br><span class="line">  <span class="comment">#此函数用来代替check_equals函数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">skip_check_equals_</span><span class="params">(state)</span>:</span></span><br><span class="line">    <span class="comment">#类似与上一题将加密后的值读出来</span></span><br><span class="line">    user_input_buffer_address = <span class="number">0x804A054</span> <span class="comment"># :integer, probably hexadecimal</span></span><br><span class="line">    user_input_buffer_length = <span class="number">16</span></span><br><span class="line">    user_input_string = state.memory.load(</span><br><span class="line">      user_input_buffer_address, </span><br><span class="line">      user_input_buffer_length)</span><br><span class="line">    </span><br><span class="line">    check_against_string = <span class="string">r'XYMKBKUHNIQYNQXE'</span> <span class="comment"># :string</span></span><br><span class="line">    <span class="comment">#比较加密后的值与预期的值，并将返回值给eax.因为在原程序中，函数的返回结果给了eax.</span></span><br><span class="line">    state.regs.eax = claripy.If(</span><br><span class="line">      user_input_string == check_against_string, </span><br><span class="line">      claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), </span><br><span class="line">      claripy.BVV(<span class="number">0</span>, <span class="number">32</span>))</span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span><span class="params">(state)</span>:</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span><span class="params">(state)</span>:</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#将正确路径的输入结果打印出来</span></span><br><span class="line">    solution = solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line">    print(solution)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>



<h3><span id="10_angr_simprocedures">10_angr_simprocedures</span></h3><p>本题介绍了一个类似hook的方式。试想在上一题中，check_equals函数被多次调用，我们不能在每次调用的地方进行hook,这样肯定使不合理的而且也无聊。因此angr提供了一个simprocedures的功能，可以用来hook一个函数。我们可以将check_equals函数给hook为我们自己的函数。</p>
<p><img src="20.png" alt></p>
<p>如题我们只需要将check_equals_ORSDDWXHZURJRBDH函数hook为我们自己处理函数即可。angr操作如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line">  <span class="comment">#定义一个类继承于simProcedure</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReplacementCheckEquals</span><span class="params">(angr.SimProcedure)</span>:</span></span><br><span class="line">    <span class="comment">#需要被hook函数的参数列表，这里被hook的是check_equals_ORSDDWXHZURJRBDH的参数列表</span></span><br><span class="line">    <span class="comment">#to_check即为上图中的s，length为上图中16，hook成功则该函数的实参自动传递进来</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, to_check, length)</span>:</span></span><br><span class="line">      user_input_buffer_address = to_check</span><br><span class="line">      user_input_buffer_length = length</span><br><span class="line">      user_input_string = self.state.memory.load(</span><br><span class="line">        user_input_buffer_address,</span><br><span class="line">        user_input_buffer_length)</span><br><span class="line">      check_against_string = <span class="string">r"ORSDDWXHZURJRBDH"</span></span><br><span class="line">      <span class="comment">#函数返回值要与被hook函数的值类型相同</span></span><br><span class="line">      <span class="keyword">return</span> claripy.If(check_against_string==user_input_string, claripy.BVV(<span class="number">1</span>,<span class="number">32</span>), claripy.BVV(<span class="number">0</span>,<span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">#被hook函数的符号，如果没有符号可以使用project.hook(),第一个参数即可以替换为被hook函数的起始地址。</span></span><br><span class="line">  check_equals_symbol = <span class="string">r"check_equals_ORSDDWXHZURJRBDH"</span> <span class="comment"># :string</span></span><br><span class="line">  project.hook_symbol(check_equals_symbol, ReplacementCheckEquals())</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span><span class="params">(state)</span>:</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span><span class="params">(state)</span>:</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    solution = solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line">    print(solution)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>

<h3><span id="11_angr_sim_scanf">11_angr_sim_scanf</span></h3><p>本题介绍如何hook掉scanf函数。同时介绍了如何在hook函数内部将位向量传递出来。</p>
<p><img src="22.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span><span class="params">(angr.SimProcedure)</span>:</span></span><br><span class="line">     <span class="comment">#此时的参数列表要和scanf一样，同时scanf的实参是可以通过该参数列表获得的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, format_string, scanf0_address, scanf1_address)</span>:</span></span><br><span class="line">      <span class="comment">#生成两个位向量，处理办法和前面绑定输入变量的方法一样</span></span><br><span class="line">      scanf0 = claripy.BVS(<span class="string">'scanf0'</span>, <span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line">      scanf1 = claripy.BVS(<span class="string">'scanf1'</span>, <span class="number">4</span>*<span class="number">8</span>)</span><br><span class="line">      self.state.memory.store(scanf0_address, scanf0, endness=project.arch.memory_endness)</span><br><span class="line">      self.state.memory.store(scanf1_address, scanf1, endness=project.arch.memory_endness)</span><br><span class="line">      <span class="comment">#因为这里生成的位向量是在simProcedure中，需要把他传递出去，因此设置给该路径的全局变量</span></span><br><span class="line">      self.state.globals[<span class="string">'solution0'</span>] = scanf0</span><br><span class="line">      self.state.globals[<span class="string">'solution1'</span>] = scanf1</span><br><span class="line">  <span class="comment">#和上题hook的做法一样</span></span><br><span class="line">  scanf_symbol = <span class="string">r"__isoc99_scanf"</span></span><br><span class="line">  project.hook_symbol(scanf_symbol, ReplacementScanf())</span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span><span class="params">(state)</span>:</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span><span class="params">(state)</span>:</span></span><br><span class="line">    stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#找到正确路径，获取该路径在ReplacementScanf中设置的位向量，即正确的输入。</span></span><br><span class="line">    stored_solutions0 = solution_state.globals[<span class="string">'solution0'</span>]</span><br><span class="line">    stored_solutions1 = solution_state.globals[<span class="string">'solution1'</span>]</span><br><span class="line">    solution =<span class="string">r"%u %u"</span>%(solution_state.solver.eval(stored_solutions0),solution_state.solver.eval(stored_solutions1))</span><br><span class="line">    print(solution)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>

<h3><span id="12_angr_veritesting">12_angr_veritesting</span></h3><p>angr有两种路径生成方式，动态符号执行(DSE)和静态符号执行(SSE)。前者为路径生成公式，在生成公式时会产生很高的负载，但是公式很容易解。后者为语句生成公式，公式能覆盖很多路径，但是公式难解。SSE不能针对大规模程序分析。Veritesting结合了DSE和SSE，减少了路径爆炸的影响，因此在生成模拟器的时候将Veritesting设置为True即可。</p>
<p><img src="21.png" alt></p>
<p>可以看到本题，无法避免路径爆炸。比较字符时，使用输入字符串与生成的字符串一一比较。如果不设置veritesting，则会导致路径爆炸的情况出现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">    path_to_binary=argv[<span class="number">1</span>]</span><br><span class="line">    project=angr.Project(path_to_binary)</span><br><span class="line">    initial_state=project.factory.entry_state()</span><br><span class="line">    <span class="comment">#将veritesting设置为True</span></span><br><span class="line">    simulation = project.factory.simgr(initial_state,veritesting=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        solution = solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line">        print(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>



<h3><span id="小总结03">小总结03</span></h3><p>如上的五个题都是在避免路径爆炸或者避免一些麻烦时引入的代替原程序部分代码办法或者采取优化性能的办法，使得路径能够完整，让模拟器能够模拟出原程序运行路径。以至于方便最后找到正确路径。</p>
<h3><span id="13_angr_static_binary">13_angr_static_binary</span></h3><p>本题处理静态编译的程序。在动态链接的程序里面，对于标准库函数的调用，angr自动的将其替换为更相应高效的simProcedure.但是在静态编译的程序里面这些函数需要我们手动替换。替换时，我们只需要将需要用到的函数替换即可，大可不必全部替换。</p>
<p><img src="23.png" alt></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">    path_to_binary=argv[<span class="number">1</span>]</span><br><span class="line">    project=angr.Project(path_to_binary)</span><br><span class="line">    initial_state=project.factory.entry_state()</span><br><span class="line"></span><br><span class="line">    __libc_start_main_address=<span class="number">0x8048D10</span></span><br><span class="line">    printf_address=<span class="number">0x804ED40</span></span><br><span class="line">    _isoc99_scanf_address=<span class="number">0x804ED80</span></span><br><span class="line">    strcmp_address=<span class="number">0x805B450</span></span><br><span class="line">    puts_address=<span class="number">0x804F350</span></span><br><span class="line">    project.hook(__libc_start_main_address,angr.SIM_PROCEDURES[<span class="string">'glibc'</span>][<span class="string">'__libc_start_main'</span>]())</span><br><span class="line">    project.hook(printf_address, angr.SIM_PROCEDURES[<span class="string">'libc'</span>][<span class="string">'printf'</span>]())</span><br><span class="line">    project.hook(_isoc99_scanf_address, angr.SIM_PROCEDURES[<span class="string">'libc'</span>][<span class="string">'scanf'</span>]())</span><br><span class="line">    project.hook(strcmp_address, angr.SIM_PROCEDURES[<span class="string">'libc'</span>][<span class="string">'strcmp'</span>]())</span><br><span class="line">    project.hook(puts_address, angr.SIM_PROCEDURES[<span class="string">'libc'</span>][<span class="string">'puts'</span>]())</span><br><span class="line"></span><br><span class="line">    simulation = project.factory.simgr(initial_state,veritesting=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Good Job."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">should_abort</span><span class="params">(state)</span>:</span></span><br><span class="line">        stdout_output = state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">b"Try again."</span> <span class="keyword">in</span> stdout_output</span><br><span class="line"></span><br><span class="line">    simulation.explore(find=is_successful, avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">        solution = solution_state.posix.dumps(sys.stdin.fileno())</span><br><span class="line">        print(solution)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>

<h3><span id="14_angr_shared_library">14_angr_shared_library</span></h3><p>本题是告诉我们如何分析不是可执行程序的二进制文件。比如典型的动态链接库。本题关键函数是在lib14_angr_shared_library.so中。14_angr_shared_library调用so文件中的validate函数，成功就返回True,否则就是False.</p>
<p><img src="25.png" alt></p>
<p><img src="24.png" alt></p>
<p><img src="26.png" alt></p>
<p><img src="27.png" alt></p>
<p>关键验证代码都在so文件中，因此本题需要angr加载so文件进行分析。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  <span class="comment">#该路径因为so文件名，因为核心函数是在so文件中</span></span><br><span class="line">  path_to_binary =argv[<span class="number">1</span>]</span><br><span class="line">  <span class="comment">#随便指定一个基地址，模仿加载so文件</span></span><br><span class="line">  base = <span class="number">0x4000000</span></span><br><span class="line">  project = angr.Project(path_to_binary, load_options=&#123; </span><br><span class="line">    <span class="string">'main_opts'</span> : &#123; </span><br><span class="line">      <span class="string">'base_addr'</span> : base </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">#创建一个指针形式的位向量，当作参数传进去validate函数，第一个参数随便指定一个值</span></span><br><span class="line">  password_pointer=claripy.BVV(<span class="number">0x3000000</span>,<span class="number">32</span>)</span><br><span class="line">  <span class="comment">#validate函数在so文件中的偏移加上基地址，模仿出程序运行时的真实地址。</span></span><br><span class="line">  validate_function_address = base+<span class="number">0x6D7</span></span><br><span class="line">  <span class="comment">#创建初始路径，直接从validate真实函数地址开始，传入相应参数</span></span><br><span class="line">  initial_state = project.factory.call_state(</span><br><span class="line">                    validate_function_address,</span><br><span class="line">                    password_pointer,</span><br><span class="line">                    <span class="number">8</span></span><br><span class="line">                  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">#创建password的位向量，将password与之前的传入指针形式的参数绑定在一起</span></span><br><span class="line">  <span class="comment">#确保validate验证的值是当前的password</span></span><br><span class="line">  password=claripy.BVS(<span class="string">'password'</span>,<span class="number">8</span>*<span class="number">8</span>)</span><br><span class="line">  initial_state.memory.store(password_pointer,password)</span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line">  <span class="comment">#validate函数的结束地址</span></span><br><span class="line">  success_address = base+<span class="number">0x783</span> </span><br><span class="line">  simulation.explore(find=success_address)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#验证validate的返回值，如果是1则验证成功，打印出来，否则当前路径无效。</span></span><br><span class="line">    solution_state.add_constraints(solution_state.regs.eax != <span class="number">0</span>)</span><br><span class="line">    solution = solution_state.solver.eval(password,cast_to=bytes).decode()</span><br><span class="line">    print(solution)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>



<h3><span id="15_angr_arbitrary_read">15_angr_arbitrary_read</span></h3><p>本题咋一看不知道说的是什么。题目本身也比较简单，根据题目命猜测想要任意地址读。</p>
<p><img src="28.png" alt></p>
<p>分析本题，其实可以通过V4的栈溢出控制s，控制s的值就可以实现任意地址读了。这个是在pwn里面一眼就看出来的东西。我就一直不明白在angr中有什么用。然后我就仔细研究代码，发现angr并不需要你懂栈溢出的原理。根据题目规定的值写好变量，然后设置好想要的预期效果，angr自动帮你生成payload，前提是题目本身就有漏洞存在。同时还可以对payload进行一些规定，比如需要写入的都是可见字符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line"></span><br><span class="line">  initial_state =project.factory.entry_state()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#hook掉scanf，与11题一样</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span><span class="params">(angr.SimProcedure)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, format_string, key , password)</span>:</span></span><br><span class="line">      scanf0 = claripy.BVS(<span class="string">'scanf0'</span>, <span class="number">32</span>)</span><br><span class="line">      scanf1 = claripy.BVS(<span class="string">'scanf1'</span>, <span class="number">20</span>*<span class="number">8</span>)</span><br><span class="line">      <span class="comment">#对字符串进行一个限制，限制为大写英文字符</span></span><br><span class="line">      <span class="keyword">for</span> char <span class="keyword">in</span> scanf1.chop(bits=<span class="number">8</span>):</span><br><span class="line">        self.state.add_constraints(char &gt;= <span class="string">'A'</span>, char &lt;= <span class="string">'Z'</span>)</span><br><span class="line"></span><br><span class="line">      scanf0_address = key</span><br><span class="line">      self.state.memory.store(scanf0_address, scanf0, endness=project.arch.memory_endness)</span><br><span class="line">      scanf1_address = password</span><br><span class="line">      self.state.memory.store(scanf1_address, scanf1)</span><br><span class="line"></span><br><span class="line">      self.state.globals[<span class="string">'solution0'</span>] = scanf0</span><br><span class="line">      self.state.globals[<span class="string">'solution1'</span>] = scanf1</span><br><span class="line"></span><br><span class="line">  scanf_symbol = <span class="string">r'__isoc99_scanf'</span>  <span class="comment"># :string</span></span><br><span class="line">  project.hook_symbol(scanf_symbol, ReplacementScanf())</span><br><span class="line"></span><br><span class="line">  <span class="comment">#设置一个回调函数，在程序调用puts函数成功之后，使用这个函数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check_puts</span><span class="params">(state)</span>:</span></span><br><span class="line">    <span class="comment">#检查调用puts参数，注意这里是调用成功了puts函数，此时esp指向返回地址，返回地址下面一个栈单位是puts参数。</span></span><br><span class="line">    puts_parameter = state.memory.load(state.regs.esp+<span class="number">0x4</span>, <span class="number">4</span>, endness=project.arch.memory_endness)</span><br><span class="line">    <span class="comment">#检查puts参数是否与'Good Job'字符串地址相同</span></span><br><span class="line">    <span class="keyword">if</span> state.se.symbolic(puts_parameter):</span><br><span class="line">      good_job_string_address = <span class="number">0x484F4A47</span> <span class="comment"># :integer, probably hexadecimal</span></span><br><span class="line">      is_vulnerable_expression = good_job_string_address==puts_parameter <span class="comment"># :boolean bitvector expression</span></span><br><span class="line">      copied_state = state.copy()</span><br><span class="line">      copied_state.add_constraints(is_vulnerable_expression)</span><br><span class="line">      <span class="comment"># Finally, we test if we can satisfy the constraints of the state.</span></span><br><span class="line">      <span class="keyword">if</span> copied_state.satisfiable():</span><br><span class="line">        <span class="comment"># Before we return, let's add the constraint to the solver for real.</span></span><br><span class="line">        state.add_constraints(is_vulnerable_expression)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># not state.se.symbolic(???)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span><span class="params">(state)</span>:</span></span><br><span class="line">    <span class="comment">#puts函数的plt表</span></span><br><span class="line">    puts_address = <span class="number">0x8048370</span></span><br><span class="line">    <span class="comment">#此处判断程序是否成功调用puts函数，调用成功就检查参数</span></span><br><span class="line">    <span class="comment">#函数返回成功说明成功打印"Good JOb"</span></span><br><span class="line">    <span class="keyword">if</span> state.addr == puts_address:</span><br><span class="line">      <span class="keyword">return</span> check_puts(state)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    solution0=solution_state.globals[<span class="string">"solution0"</span>]</span><br><span class="line">    solution1=solution_state.globals[<span class="string">"solution1"</span>]</span><br><span class="line">    solution = <span class="string">r'%u %20s'</span>%(solution_state.solver.eval(solution0),solution_state.solver.eval(solution1,cast_to=bytes).decode(<span class="string">"UTF-8"</span>))</span><br><span class="line">    print(solution)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>

<h3><span id="16_angr_arbitrary_write">16_angr_arbitrary_write</span></h3><p>使用angr生成对存在漏洞的程序进行任意地址写的payload。</p>
<p><img src="29.png" alt></p>
<p>如题，本题不加任何漏洞利用，则永远不可能打印出”Good Job.” 因此需要使用angr自动生成一串payload，将password_buffer指向的内存改为”NDYNWEUJ”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line">  initial_state = project.factory.entry_state()</span><br><span class="line">  <span class="comment">#与上题一样</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ReplacementScanf</span><span class="params">(angr.SimProcedure)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, format_string,key , password)</span>:</span></span><br><span class="line">      scanf0 = claripy.BVS(<span class="string">'scanf0'</span>, <span class="number">32</span>)</span><br><span class="line">      scanf1 = claripy.BVS(<span class="string">'scanf1'</span>, <span class="number">20</span>*<span class="number">8</span>)</span><br><span class="line">      <span class="keyword">for</span> char <span class="keyword">in</span> scanf1.chop(bits=<span class="number">8</span>):</span><br><span class="line">        self.state.add_constraints(char &gt;= <span class="string">'A'</span>, char &lt;= <span class="string">'Z'</span>)</span><br><span class="line"></span><br><span class="line">      scanf0_address = key</span><br><span class="line">      self.state.memory.store(scanf0_address, scanf0, endness=project.arch.memory_endness)</span><br><span class="line">      scanf1_address = password</span><br><span class="line">      self.state.memory.store(scanf1_address, scanf1)</span><br><span class="line"></span><br><span class="line">      self.state.globals[<span class="string">'solution0'</span>] = scanf0</span><br><span class="line">      self.state.globals[<span class="string">'solution1'</span>] = scanf1</span><br><span class="line"></span><br><span class="line">  scanf_symbol = <span class="string">r'__isoc99_scanf'</span>  <span class="comment"># :string</span></span><br><span class="line">  project.hook_symbol(scanf_symbol, ReplacementScanf())</span><br><span class="line"></span><br><span class="line">  <span class="comment">#该函数是在嗲用strncpy起作用</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">check_strncpy</span><span class="params">(state)</span>:</span></span><br><span class="line">    <span class="comment">#strncpy(dest,src,len)</span></span><br><span class="line">    <span class="comment">#因此第一个参数是dest,在调用strncpy之后 esp指向的是返回地址，下面一个栈单位是第一个参数，紧接着第二个参数，第三个参数。。。。</span></span><br><span class="line">    strncpy_dest = state.memory.load(state.regs.esp+<span class="number">0x4</span>,<span class="number">4</span>,endness=project.arch.memory_endness)</span><br><span class="line">    strncpy_src = state.memory.load(state.regs.esp+<span class="number">0x8</span>,<span class="number">4</span>,endness=project.arch.memory_endness)</span><br><span class="line">    strncpy_len = state.memory.load(state.regs.esp+<span class="number">0xc</span>,<span class="number">4</span>,endness=project.arch.memory_endness)</span><br><span class="line">    <span class="comment">#读出src指向的内容</span></span><br><span class="line">    src_contents = state.memory.load(strncpy_src,strncpy_len)</span><br><span class="line">    <span class="keyword">if</span> state.se.symbolic(src_contents) <span class="keyword">and</span> state.se.symbolic(strncpy_dest):</span><br><span class="line">      password_string = <span class="string">r"NDYNWEUJ"</span> <span class="comment"># :string</span></span><br><span class="line">      buffer_address = <span class="number">0x57584344</span> <span class="comment"># :integer, probably in hexadecimal</span></span><br><span class="line">      <span class="comment">#检查src的前八个字节是否与password相同</span></span><br><span class="line">      does_src_hold_password = src_contents[<span class="number">-1</span>:<span class="number">-64</span>] == password_string</span><br><span class="line">      <span class="comment">#检查dest的地址是否与password_buffer地址相同</span></span><br><span class="line">      does_dest_equal_buffer_address = buffer_address == strncpy_dest</span><br><span class="line">      <span class="keyword">if</span> state.satisfiable(extra_constraints=(does_src_hold_password, does_dest_equal_buffer_address)):</span><br><span class="line">        state.add_constraints(does_src_hold_password, does_dest_equal_buffer_address)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="comment"># not state.se.symbolic</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation = project.factory.simgr(initial_state)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is_successful</span><span class="params">(state)</span>:</span></span><br><span class="line">    <span class="comment">#strncpy的plt表</span></span><br><span class="line">    strncpy_address = <span class="number">0x8048410</span></span><br><span class="line">    <span class="comment">#调用strncpy成功时，调用check_strncpy.</span></span><br><span class="line">    <span class="keyword">if</span> state.addr == strncpy_address:</span><br><span class="line">      <span class="keyword">return</span> check_strncpy(state)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">  simulation.explore(find=is_successful)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state = simulation.found[<span class="number">0</span>]</span><br><span class="line">    solution0=solution_state.globals[<span class="string">"solution0"</span>]</span><br><span class="line">    solution1=solution_state.globals[<span class="string">"solution1"</span>]</span><br><span class="line">    solution = <span class="string">r'%u %20s'</span>%(solution_state.solver.eval(solution0),solution_state.solver.eval(solution1,cast_to=bytes).decode(<span class="string">"UTF-8"</span>))</span><br><span class="line">    print(solution)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>

<h3><span id="17_angr_arbitrary_jump">17_angr_arbitrary_jump</span></h3><p>任意地址跳转。实际上就是通过栈溢出控制返回地址。不过payload使用angr自动生成。</p>
<p><img src="30.png" alt></p>
<p><img src="31.png" alt></p>
<p><img src="32.png" alt></p>
<p>在read_input()函数中，存在栈溢出漏洞。我们需要控制函数跳转到print_good函数。</p>
<p>首先需要介绍一些无约束的路径。当程序进入了下一条指令可以是任何地址的时候，该条路径就属于无约束路径。一般来说这种路径是没有意义的，angr会默认抛弃掉该条路径，使该条路径变为unconstrained。本题无约束的路径正是我们需要的。当初发栈溢出之后，该路径就会变为无约束路径。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(argv)</span>:</span></span><br><span class="line">  path_to_binary = argv[<span class="number">1</span>]</span><br><span class="line">  project = angr.Project(path_to_binary)</span><br><span class="line">  <span class="comment">#将输入流换为指定的位向量</span></span><br><span class="line">  input_str=claripy.BVS(<span class="string">"payload"</span>,<span class="number">100</span>*<span class="number">8</span>)</span><br><span class="line">  initial_state = project.factory.entry_state(stdin=input_str)</span><br><span class="line">  <span class="comment">#stashes中的一些列表不是默认开启的。stashes中保存则不同类别的路径</span></span><br><span class="line">  <span class="comment">#active为激活路径，unconstrained为无约束路径，found路径为成功找到的路径</span></span><br><span class="line">  simulation = project.factory.simgr(</span><br><span class="line">                initial_state, save_unconstrained=<span class="literal">True</span>,</span><br><span class="line">                stashes=&#123;</span><br><span class="line">                  <span class="string">'active'</span>: [initial_state],</span><br><span class="line">                  <span class="string">'unconstrained'</span>:[],</span><br><span class="line">                  <span class="string">'found'</span>:[],</span><br><span class="line">                  <span class="string">'not_needed'</span>:[]</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">has_found_solution</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> simulation.found</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">has_unconstrained</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> simulation.unconstrained</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">has_active</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> simulation.active</span><br><span class="line"></span><br><span class="line">  <span class="comment">#循环找到每条未成功但是是激活或者无约束的路径</span></span><br><span class="line">  <span class="keyword">while</span> (has_active() <span class="keyword">or</span> has_unconstrained()) <span class="keyword">and</span> (<span class="keyword">not</span> has_found_solution()):</span><br><span class="line">    <span class="keyword">for</span> unconstrained_state <span class="keyword">in</span> simulation.unconstrained:</span><br><span class="line">      <span class="comment">#针对每个无约束的路径，约束该路径的eip的值</span></span><br><span class="line">      unconstrained_state.add_constraints(unconstrained_state.regs.eip == <span class="number">0x42585249</span>)</span><br><span class="line">      <span class="comment">#如果该无约束路径的eip是我们想要的，则将该路径转为成功路径。</span></span><br><span class="line">      simulation.move(<span class="string">'unconstrained'</span>, <span class="string">'found'</span>)</span><br><span class="line">    simulation.step()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> simulation.found:</span><br><span class="line">    solution_state=simulation.found[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#约束该路径的输入为可见字符，若不是，则抛弃该路径。</span></span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> input_str.chop(bits=<span class="number">8</span>):</span><br><span class="line">      solution_state.add_constraints(byte &gt;= <span class="string">'A'</span>, byte &lt;= <span class="string">'Z'</span>)</span><br><span class="line">    solution = solution_state.solver.eval(input_str,cast_to=bytes).decode()</span><br><span class="line">    print(solution)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'Could not find the solution'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  main(sys.argv)</span><br></pre></td></tr></table></figure>

<h2><span id="总结">总结</span></h2><p>至此，angr的基础学习就已经结束了。通过上述十几个例题的展示，angr其实理解起来并不困难。当我们需要一串字符来触发程序中某种东西的时候，就可以使用angr。angr并不需要跑完整个程序的代码，可以只执行一个函数（调用链接库的函数），也可以跳过一个函数去执行其他代码（hook），还可以在原程序基础上加入自己想要的代码（约束）。而且通过在angr脚本中加入的约束和程序本身的代码，angr模拟原程序运行，不断改变输入，从而改变和生成不同路径，可以自动帮我们得出到达目的的输入。</p>

      </div>

      <div class="article-footer">
        
      </div>

      <div class="article-navs">
        
<nav class="card-container card-article-nav">
  <div class="card-wrap">
    
      <div id="article-nav-newer" class="card-item img">
        <article>
          
            <div class="card-cover" style="background-image: url(/css/images/lake.jpg)"></div>
          
          <a class="card-link article-nav-link" href="/2023/03/28/Fuzzing-C-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"></a>
          <strong class="article-nav-caption">Newer</strong>
          <p class="article-nav-title">
            
              Fuzzing C#环境搭建以及实测
            
          </p>
        </article>
      </div>
    
    
      <div id="article-nav-older" class="card-item img">
        <article>
          
            <div class="card-cover" style="background-image: url(/css/images/sea.jpg)"></div>
          
          <a class="card-link article-nav-link" href="/2022/04/02/notebook/"></a>
          <strong class="article-nav-caption">Older</strong>
          <p class="article-nav-title">
            
              Mysql数据库笔记
            
          </p>
        </article>
      </div>
    
  </div>
</nav>

      </div>
      
      

  
  <div class="valine-container">
    <div id="valine_thread" class="valine-thread"></div>
  </div>

  
  


    </div>
  </article>
</div></section>

    <!-- footer container -->
<footer id="footer" class="footer">
  <div class="footer-container">
    <p>&copy; 2023 <a href="/" target="_blank">Whali3n51</a></p>

    
      <p id="hitokoto"></p>
      <script src="https://v1.hitokoto.cn/?c=f&amp;encode=js&select=%23hitokoto" defer></script>
    

    
  </div>
</footer>
  </div>

  
  


  <!-- aplayer 音频 start -->
  <link rel="stylesheet" href="/lib/APlayer.min.css">
  <script src="/lib/APlayer.min.js"></script>
  <script type="text/javascript">
    const aplayer = document.querySelectorAll(".aplayer");
    aplayer && initaplayer(aplayer);
    function initaplayer(els) {
      let elsArr = Array.from(els);
      elsArr.forEach(el => {
        new APlayer({
          container: el,
          audio: { ...el.dataset },
          theme: "#b7daff",
          lrcType: 3,
          autoplay: false,
          loop: false,
          mutex: true,
        });
      });
    }
  </script>
  <!-- aplayer 音频 end -->
  

<!-- dplayer 视频 start -->
<link rel="stylesheet" href="/lib/DPlayer.min.css">
<script src="/lib/DPlayer.min.js"></script>
<script type="text/javascript">
  const dplayer = document.querySelectorAll(".dplayer");
  dplayer && initDPlayer(dplayer);
  function initDPlayer(els) {
    let elsArr = Array.from(els);
    elsArr.forEach(el => {
      let url = el.dataset.url;
      let cover = el.dataset.cover;
      new DPlayer({
        container: el,
        video: { url: url, pic: cover },
        theme: "#b7daff",
        autoplay: false,
        loop: false,
        mutex: true,
      });
    });
  }
</script>
<!-- dplayer 视频 end -->


<!-- waterfall 瀑布流 start -->
<script src="/lib/waterfall.min.js"></script>
<script type="text/javascript">

const waterfalls = document.querySelectorAll(".waterfall-container");

if (waterfalls && waterfalls.length > 0) {
  waterfalls.forEach((waterfall, index) => {
    let cls = "waterfall-container-" + index;
    waterfall.classList.add(cls);
    initWaterfall(cls, waterfall);
  });
}

function initWaterfall(selector, el) {
  const options = {};
  if (Object.keys(el.dataset).length > 0) {
    for (let k in el.dataset) {
      options[k] = el.dataset[k];
    }
  }
  waterfall(`.${selector}`, options);
}
</script>
<!-- waterfall 瀑布流 end -->


  <!-- zoom start -->
  <script src="/lib/zoom.min.js"></script>
  <script type="text/javascript">
    document.querySelector(".article-content") && zoom(".article-content");
  </script>
  <!-- zoom end -->
  



  


  


  



<script src="/js/script.js"></script>
  
  <!-- 尾部用户自定义相关内容 -->

</body>
</html>